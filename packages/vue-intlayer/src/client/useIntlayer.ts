import type { LocalesValues } from '@intlayer/config/client';
import { DictionaryKeys } from '@intlayer/core';
import { computed, inject, reactive, watchEffect } from 'vue';
// @ts-ignore intlayer declared for module augmentation
import type { IntlayerDictionaryTypesConnector } from 'intlayer';
import { getIntlayer } from '../getIntlayer';
import { DeepTransformContent } from '../plugins';
import { INTLAYER_SYMBOL, IntlayerProvider } from './installIntlayer';

/** guard utility - true only for objects generated by `renderIntlayerNode()` */
export const isUpdatableNode = (
  val: unknown
): val is { __update: (n: unknown) => void } =>
  !!val &&
  typeof val === 'object' &&
  typeof (val as any).__update === 'function';

export const useIntlayer = <T extends DictionaryKeys>(
  key: T,
  locale?: LocalesValues
): DeepTransformContent<IntlayerDictionaryTypesConnector[T]['content']> => {
  const intlayer = inject<IntlayerProvider>(INTLAYER_SYMBOL)!;

  /** which locale should we use right now? */
  const localeTarget = computed(() => locale ?? intlayer?.locale.value);

  /** a *stable* reactive dictionary object */
  const content = reactive({}) as DeepTransformContent<
    IntlayerDictionaryTypesConnector[T]['content']
  >;

  /** whenever `key` or `locale` change, refresh the dictionary */
  watchEffect(() => {
    const next = getIntlayer(key, localeTarget.value);

    for (const prop in next) {
      const current = content[prop] as unknown;
      const incoming = next[prop];

      if (prop in content && isUpdatableNode(current)) {
        /** same entry -> patch in-place */
        current.__update(incoming as any);
      } else {
        /** new entry *or* not an IntlayerNode -> replace wholesale */
        content[prop] = incoming;
      }
    }

    // remove stale entries
    for (const prop in content) {
      if (!(prop in next)) delete content[prop];
    }
  });

  return content; // all consumers keep full reactivity, *even after destructuring*
};
